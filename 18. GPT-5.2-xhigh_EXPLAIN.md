以下我會用「你已熟悉的 React / JS 內建結構」當底，去把這段程式的 **資料結構設計**、**Heap / Binary Tree 的概念**、以及你要的 **handleMsg / onRowSubmit / TTL timer 的逐步模擬**講清楚。

> 你看到的 `heap` 這裡指的是**資料結構的 heap（priority queue / binary heap）**，不是 JS 引擎的「記憶體 heap」。兩者同名但完全不同概念。

---

## 0) 這整段程式到底在解什麼問題？

這個 Demo 做的是「交易訊息（新訂單）」的列表管理：

- 每收到一筆新訊息（`handleMsg`）就新增一列 row（Pending / 未回覆）。
- 你可以對某列按 Reply（`onRowSubmit`），把它變成 Replied（已回覆），並設定 TTL（幾秒後自動過期取消）。
- 過期時會呼叫 `cancelOrder(id)`，並把那列從表格移除。
- **每個 stockId 最多只保留：**
  - 1 筆 unreplied（Pending）
  - 1 筆 replied（Replied）
  - 同 stock 的重複會「取代舊的」。

而「自動過期」最關鍵的難點是：  
你可能同時有很多已回覆 rows 都有不同 TTL，你必須快速知道「下一個最早過期的是誰」，並只用 **一個 timer** 去排程。

這就是 heap 出場的原因：用 heap 當作「到期時間排序的優先佇列」。

---

## 1) Hook 內部的 5 個核心資料結構（都放在 ref）

在 `useRowDataManager` 裡有：

```js
const rowsRef = useRef([]);
const byIdRef = useRef(new Map());
const unrepliedRef = useRef(new Map());
const repliedRef = useRef(new Map());
const ttlHeapRef = useRef(new LazyHeap());
const timerRef = useRef(null);

const [displayRows, setDisplayRows] = useState([]);
```

### 1.1 `rowsRef.current`：Array（顯示順序用）
- **用途**：表格要依順序 render，所以要有一個 array。
- 裡面放 row object（同一個物件也會被 Map 指到）。
- 會 `push` 新 row、`splice` 刪中間、`shift` 刪最舊。
- `rows.indexOf(row)` 用的是 **物件引用相等**（同一個 object instance）。

> 你可能會問：為什麼不用 state 存 rows？  
> 因為這裡用 ref 直接 mutate，比較像「資料庫」，最後再 `flush()` 一次把 UI 更新（減少頻繁 re-render）。

---

### 1.2 `byIdRef.current`：Map<id, row>（用 id 快速找 row）
- **用途**：`onRowSubmit({id})` 進來時要 O(1) 找到那列。
- 如果只靠 `rows` array，你要找 id 會變 O(n)。

---

### 1.3 `unrepliedRef.current`：Map<stockId, row>（每檔最多一筆 Pending）
- **用途**：當新訂單進來（同 stockId），要把「舊 pending」移除，只保留最新 pending。
- 所以 `handleMsg` 一開始會：
  - `oldUnreplied = unreplied.get(stockId)`
  - 有的話就從 `rows` 刪掉 + `byId` 刪掉 + `unreplied` 刪掉

---

### 1.4 `repliedRef.current`：Map<stockId, row>（每檔最多一筆 Replied）
- **用途**：當你回覆一筆 pending，會把它登記成「該 stock 的 replied」。
- 若該 stock 之前已經有 replied（舊的），就移除舊的 replied（只保留最新）。

---

### 1.5 `ttlHeapRef.current`：LazyHeap（管理到期時間的「最小堆」min-heap）
- **用途**：快速找「最早到期」的 replied row。
- heap 內存的是 `{ id, expiryTime }`，只管到期，不直接存 row object。
- 你可以想成：`ttlHeap` 是一個「依 expiryTime 排序的 priority queue」。

---

### 1.6 `timerRef.current`：目前排程的 setTimeout
- 原則：**永遠只維持一個 setTimeout**，指向「下一個最早到期」。
- 如果新增了一個更早到期的項目，就 clear 掉舊 timer、改排新的。

---

### 1.7 `displayRows`：唯一會觸發 render 的 state
`rowsRef.current` 是 mutable，不會讓 React 重新 render。  
所以有一個 `flush()`：

```js
const flush = useCallback(() => {
  setDisplayRows(rowsRef.current.slice());
}, []);
```

- `slice()` 建一個新 array，讓 React state 變更、重新 render。
- 但 row objects 本身仍是同一批物件（只是 array 換了）。

---

## 2) 你需要的 Tree / Binary Tree / Heap 觀念（用最貼近 JS 的方式講）

### 2.1 Tree（樹）
- 一堆節點（node）用 parent/children 連起來。
- 沒有限制每個節點可有幾個 children。

### 2.2 Binary Tree（二元樹）
- Tree 的一種：每個節點最多 2 個 children（left/right）。

### 2.3 Binary Heap（二元堆，這裡用的是 Min-Heap）
Binary Heap 是一種特殊的 binary tree，兩個重點：

1. **Complete Binary Tree（完全二元樹）形狀**  
   - 每一層從左到右塞滿（最後一層可以沒塞滿，但也是靠左）
   - 這個形狀保證你可以用 array 很自然表示

2. **Heap property（堆序性）**  
   - Min-heap：每個 parent 的 key（這裡是 `expiryTime`）都 ≤ 子節點
   - 所以根節點（index 0）永遠是最小的（最早到期）

---

## 3) Heap 為什麼可以用 Array 存？（這段是你理解 bubbleUp / sinkDown 的關鍵）

在 array 表示 heap 時：

- `parent(i) = floor((i-1)/2)`
- `left(i) = 2*i + 1`
- `right(i) = 2*i + 2`

程式裡用 bit operation 寫：

```js
const p = (i - 1) >>> 1;   // parent
const l = (i << 1) + 1;    // left
const r = l + 1;           // right
```

例如 heap array 有 7 個元素（index 0..6），樹長這樣：

```
index:    0
        /   \
       1     2
      / \   / \
     3  4  5  6
```

---

## 4) `LazyHeap`：這個 heap 特別之處是「Lazy deletion（懶刪除）」

### 4.1 為什麼要「懶刪除」？
一般 heap 很擅長做：
- `push`（插入）
- `pop`（取出最小）
- `peek`（看最小）

但它 **不擅長** 做「刪掉任意 id 的那個元素」，因為你不知道那個元素在 heap array 的哪個 index。  
如果你要硬刪，你得 O(n) 搜尋 + 再重建 heap。

這裡的需求是：
- 當「某筆 replied 被取代/移除」時，要把它的 TTL 排程也取消。

所以這裡用懶刪除：

- `remove(id)`：不去 heap array 找它、也不移除它  
  只做：`deleted.add(id)`（O(1)）
- 之後在 `peekValid()` / `popValid()` 時：
  - 如果 heap top 的 id 在 deleted 裡，就把它 pop 掉（真的移掉）
  - 一直清到 top 是有效的為止

這就是 `_cleanTop()`：

```js
_cleanTop() {
  while (this.heap.length > 0 && this.deleted.has(this.heap[0].id)) {
    this.deleted.delete(this.heap[0].id);
    this._pop();
  }
}
```

> 直覺：  
> 「刪除」先做一個 *刪除標記*，  
> 真正清理延後到它剛好跑到 heap top（也就是我們真的在意它的時候）。

---

### 4.2 `push`：插入並 bubbleUp
```js
push(id, expiryTime) {
  this.heap.push({ id, expiryTime });
  this._bubbleUp(this.heap.length - 1);
}
```

bubbleUp 做的事：
- 新元素先放到 array 最尾端（維持 complete tree 形狀）
- 然後一路跟 parent 比 expiryTime
- 若比 parent 小，就交換，直到堆序性成立

---

### 4.3 `popValid`：先 cleanTop，再 pop
- 先把已刪除但卡在 top 的元素清掉
- 再真的 pop top（最早 expiry）

`_pop()` 的典型 heap pop：
- 取出 top
- 把 last element 放到 top
- sinkDown 讓它回到正確位置（維持堆序性）

---

## 5) `handleMsg`：新訂單進來時 rows/byId/unreplied/replied/heap 怎麼動？

`handleMsg(msg)` 的邏輯可以拆成 4 步：

### 5.1 取出 4 個主要容器（只是取引用）
```js
const rows = rowsRef.current;
const byId = byIdRef.current;
const unreplied = unrepliedRef.current;
const replied = repliedRef.current;
```

> 注意：這些都是同一份資料（ref），不是複製。

### 5.2 若同 stock 已有 pending（unreplied），先刪掉舊 pending
```js
const oldUnreplied = unreplied.get(stockId);
if (oldUnreplied) {
  const idx = rows.indexOf(oldUnreplied);
  if (idx !== -1) rows.splice(idx, 1);
  byId.delete(oldUnreplied.id);
  unreplied.delete(stockId);
}
```

關鍵點：
- 刪 row 需要從 **rows** 刪掉（UI 不再顯示）
- 同時從 **byId** 刪掉（避免之後用 id 找到幽靈 row）
- 從 **unreplied** 刪掉（這個 stock 不再指向舊 row）

這一步 **不會動 replied，也不會動 heap**（pending 沒有 TTL）。

### 5.3 建立新 row，加入 rows + byId + unreplied
```js
const newRow = { id: nextId(), ... pending fields ... };

rows.push(newRow);
byId.set(newRow.id, newRow);
unreplied.set(stockId, newRow);
```

### 5.4 控制 rows 最多 300 筆（超過就 shift 最舊）
```js
while (rows.length > 300) {
  const removed = rows.shift();
  byId.delete(removed.id);

  if (unreplied.get(removed.stockId) === removed) unreplied.delete(removed.stockId);

  if (replied.get(removed.stockId) === removed) {
    replied.delete(removed.stockId);
    ttlHeapRef.current.remove(removed.id);
  }
}
```

重點：
- 移除最舊 row 可能是 pending 或 replied。
- 如果移除的是 replied，而且它剛好是該 stock 的 replied row：
  - 要從 `replied` map 移除
  - 並且 `heap.remove(removed.id)` 把它的 TTL 排程懶刪掉（避免之後過期還去 cancel）

### 5.5 flush 更新 UI
`flush()` 會 setState，讓畫面更新。

---

## 6) `onRowSubmit`：回覆訂單並設定 TTL 時怎麼動？

### 6.1 找 row，若不存在或已回覆就忽略
```js
const row = byId.get(id);
if (!row || row.repliedTime) return;
```

### 6.2 同 stock 若已有 replied（舊回覆），先移除舊 replied + 懶刪 heap
```js
const oldReplied = replied.get(stockId);
if (oldReplied && oldReplied !== row) {
  const idx = rows.indexOf(oldReplied);
  if (idx !== -1) rows.splice(idx, 1);
  byId.delete(oldReplied.id);
  replied.delete(stockId);
  heap.remove(oldReplied.id);
}
```

這確保「每個 stock 同時只有一筆 replied」。

### 6.3 把這列改成 replied（直接 mutate row object）
```js
row.repliedTime = Date.now();
row.qty = qty;
row.price = price;

unreplied.delete(stockId);
replied.set(stockId, row);
```

### 6.4 若 TTL > 0，把它加入 heap，並重新排程 timer
```js
if (!isExpiry && ttl > 0) {
  heap.push(id, Date.now() + ttl * 1000);
  scheduleTimer();
}
```

---

## 7) Timer 的核心：永遠排「下一個最早到期」的那一筆

### 7.1 `scheduleTimer()`
```js
if (timerRef.current) clearTimeout(timerRef.current);

const next = ttlHeapRef.current.peekValid();
if (!next) return;

const delay = Math.max(0, next.expiryTime - Date.now());
timerRef.current = setTimeout(processExpiries, delay);
```

意思是：
1. 先把舊 timer 清掉（避免同時多個 timer）
2. 從 heap 看最早到期的那筆（`peekValid()` 會順便把「已懶刪」的 top 清掉）
3. 計算 delay
4. 設定 `setTimeout(processExpiries, delay)`

---

### 7.2 `processExpiries()`：時間到了，可能一次處理多筆
```js
while (true) {
  const next = heap.peekValid();
  if (!next || next.expiryTime > now) break;

  heap.popValid();
  const row = byId.get(next.id);
  if (row) {
    cancelOrder(row.id);
    // 從 rows/byId/replied 移除
  }
}
flush();
scheduleTimer();
```

為什麼用 while？
- JS timer 不保證精準，可能延遲（例如頁籤 background、主執行緒忙）
- 所以這裡一次把「所有已經過期」的都清掉，避免漏掉

最後一定再 `scheduleTimer()`：
- 因為處理掉一些到期項後，「下一個到期時間」會變

---

# 8) 你要的「逐步模擬」：handleMsg 新訂單、回覆、TTL、timer 怎麼跑

我用一個具體時間線來跑，讓你看到 `rows / byId / unreplied / replied / heap / timer` 每一步的變化。

## 8.0 初始狀態（t = 0.0s）
```txt
rows      = []
byId      = Map()
unreplied = Map()
replied   = Map()
heap      = []          (heap.heap array)
deleted   = Set()       (heap.deleted)
timer     = null
```

---

## 8.1 t = 0.0s：收到新訂單 AAPL（handleMsg）
msg: `{ stockId: 'AAPL', time: 0 }`

- unreplied 沒有 AAPL，所以不刪舊的
- newRow id = 1

結果：
```txt
rows = [
  #1 {id:1, stockId:'AAPL', repliedTime:null, qty:null, price:null}
]

byId = { 1 -> #1 }

unreplied = { 'AAPL' -> #1 }

replied = { }

heap = [ ]      (沒有 TTL 的事發生)
deleted = { }
timer = null
```

---

## 8.2 t = 1.0s：收到新訂單 MSFT（handleMsg）
newRow id = 2

```txt
rows = [ #1(AAPL Pending), #2(MSFT Pending) ]

byId = { 1->#1, 2->#2 }

unreplied = { 'AAPL'->#1, 'MSFT'->#2 }

replied = { }

heap = [ ]
timer = null
```

---

## 8.3 t = 2.0s：又收到 AAPL 新訂單（handleMsg）
這一步會展示「同 stock 只保留一筆 pending」。

- `oldUnreplied = unreplied.get('AAPL')` 會拿到 #1
- 先從 rows 移除 #1、byId 刪 1、unreplied 刪 AAPL
- 再新增 newRow id = 3

結果：
```txt
rows = [
  #2(MSFT Pending),
  #3(AAPL Pending)   // #1 被取代消失
]

byId = { 2->#2, 3->#3 }

unreplied = { 'MSFT'->#2, 'AAPL'->#3 }

replied = { }

heap = [ ]
timer = null
```

---

## 8.4 t = 2.5s：回覆 MSFT 的 #2，TTL = 5 秒（onRowSubmit）
submission: `{ id: 2, qty: ..., price: ..., ttl: 5 }`

做的事：
1. `row = byId.get(2)` → #2 存在且 unreplied
2. `oldReplied = replied.get('MSFT')` → 沒有
3. 把 #2 改成 replied（填 `repliedTime/qty/price`）
4. `unreplied.delete('MSFT')`
5. `replied.set('MSFT', #2)`
6. `heap.push(2, expiry=2.5s+5s=7.5s)`
7. `scheduleTimer()`：排程 7.5s 的 timer

結果：
```txt
rows = [
  #2(MSFT Replied, repliedTime=2.5s),
  #3(AAPL Pending)
]

byId = { 2->#2, 3->#3 }

unreplied = { 'AAPL'->#3 }

replied = { 'MSFT'->#2 }

heap.heap = [
  (id:2, exp:7.5s)
]
deleted = { }

timer = setTimeout(processExpiries, delay=5.0s)  // 目標時間 t=7.5s
```

---

## 8.5 t = 3.0s：回覆 AAPL 的 #3，TTL = 5 秒（onRowSubmit）
expiry = 3.0s + 5s = 8.0s

heap push 後：
- heap 會用 min-heap 排序，最小 exp 在 top
- 現在 (2,7.5s) 比 (3,8.0s) 小，所以 top 仍是 #2

`scheduleTimer()` 會：
- clear 舊 timer
- peek 最早（仍是 7.5s）
- 再設一次 timer（仍指向 7.5s）

結果：
```txt
rows = [
  #2(MSFT Replied exp@7.5),
  #3(AAPL Replied exp@8.0)
]

byId = { 2->#2, 3->#3 }

unreplied = { }

replied = { 'MSFT'->#2, 'AAPL'->#3 }

heap.heap 可能長這樣（min-heap）：
index 0: (2, 7.5s)
index 1: (3, 8.0s)

deleted = { }

timer = setTimeout(... target t=7.5s)
```

---

## 8.6 t = 4.0s：又收到 MSFT 新訂單（handleMsg）
注意：現在 MSFT 已經是 replied（#2），`unreplied` 裡沒有 MSFT。

所以 `handleMsg` 會直接新增 pending #4，不會碰 replied #2。

結果：
```txt
rows = [
  #2(MSFT Replied),
  #3(AAPL Replied),
  #4(MSFT Pending)
]

byId = { 2->#2, 3->#3, 4->#4 }

unreplied = { 'MSFT'->#4 }

replied = { 'MSFT'->#2, 'AAPL'->#3 }

heap.heap = [ (2,7.5s), (3,8.0s) ]
timer 仍指向 t=7.5s
```

---

## 8.7 t = 4.5s：回覆 MSFT 的 #4，TTL = 5 秒（onRowSubmit）
這一步會展示「同 stock 只保留一筆 replied」+ **lazy deletion**。

expiry = 4.5s + 5s = 9.5s

流程重點：
1. 找到 row #4，尚未 replied ✅
2. `oldReplied = replied.get('MSFT')` → 是 #2，而且 oldReplied !== row(#4)
3. 移除舊 replied #2：
   - 從 rows 刪 #2
   - byId.delete(2)
   - replied.delete('MSFT')
   - heap.remove(2)  ← **lazy deletion：只做 deleted.add(2)**
4. 把 #4 設為 replied，replied.set('MSFT', #4)，unreplied.delete('MSFT')
5. heap.push(4, 9.5s)
6. scheduleTimer：
   - clear 舊 timer（原本指向 7.5s）
   - peekValid：如果 heap top 剛好是 (2,7.5s) 而且 id=2 在 deleted
     - `_cleanTop()` 會把 (2,7.5s) 真正 pop 掉
   - 下一個有效 top 會變成 (3,8.0s)
   - timer 改排到 8.0s

結果（重點看 heap 與 deleted）：
```txt
rows = [
  #3(AAPL Replied exp@8.0),
  #4(MSFT Replied exp@9.5)
]
byId = { 3->#3, 4->#4 }

unreplied = { }
replied = { 'AAPL'->#3, 'MSFT'->#4 }

heap 在 scheduleTimer.peekValid() 時會清 top：
- 原本 heap 可能包含 (2,7.5), (3,8.0), (4,9.5)
- deleted = {2}
- peekValid 看到 top 是 2 且已刪 → 把它 pop 掉

清完後 heap.heap 會剩：
[ (3,8.0s), (4,9.5s) ]   // 3 是最早到期

deleted = { }            // 2 已被真正清掉，所以 deleted 也移除 2

timer = setTimeout(... target t=8.0s)
(注意：原本 t=7.5s 的 timer 已被 clear，不會觸發)
```

> 這段就是 LazyHeap 的價值：  
> 你不需要 O(n) 去 heap 裡找 #2 在哪裡，把它刪掉；你只要 `deleted.add(2)`，等它冒到 top 再清。

---

## 8.8 t = 8.0s：timer 觸發 `processExpiries()`
此時 now = 8.0s

heap top 是 (3,8.0s)，到期了：

1. `peekValid()` → (3,8.0s) 且 exp <= now
2. `popValid()` pop 掉它
3. `row = byId.get(3)` → 找到 #3
4. 執行取消與移除：
   - `cancelOrder(3)`
   - 從 rows 移除 #3
   - byId.delete(3)
   - 如果 replied.get('AAPL') === #3 → replied.delete('AAPL')

處理完後再 `scheduleTimer()`：
- heap top 變 (4,9.5s)
- timer 排到 9.5s

結果：
```txt
rows = [ #4(MSFT Replied exp@9.5) ]

byId = { 4->#4 }
unreplied = { }
replied = { 'MSFT'->#4 }

heap.heap = [ (4,9.5s) ]
timer = setTimeout(... target t=9.5s)
```

---

## 8.9 t = 9.5s：timer 再次觸發 `processExpiries()`
同理，(4,9.5s) 到期：

- cancelOrder(4)
- rows 刪 #4
- byId.delete(4)
- replied.delete('MSFT')
- heap 清空
- scheduleTimer 發現 `peekValid()` 沒有 next → 不排 timer

結果回到乾淨狀態：
```txt
rows = []
byId = {}
unreplied = {}
replied = {}
heap.heap = []
timer = null
```

---

# 9) 你可以用一句話記住 timer 設計

- heap 負責回答：**「下一個最早到期的是誰？」**
- scheduleTimer 負責做：**「我永遠只排一個 timer，排到那個最早到期」**
- processExpiries 負責做：**「timer 觸發後，把所有已到期的都一次清掉，再排下一個」**

這個模式在 server/client 都常見（本質是 priority queue + single timer）。

---

## 10) 一些你可能會在意的細節（偏工程觀點）

### 10.1 為什麼 rows 裡刪元素用 `indexOf + splice`，不覺得慢？
- 是 O(n)，但 n 被硬限制在 300。
- 300 這種量級下 O(n) 很合理，維護成本低。

### 10.2 如果某筆 row 被移除，但 heap 裡忘記 remove 會怎樣？
`processExpiries` 這段：

```js
const row = byIdRef.current.get(next.id);
if (row) { ... }  // 沒找到就跳過
```

- 沒找到 row 就不會 cancel / 不會動 rows
- 但 heap 那個 id 仍會被 pop 掉（到期時）
- 會造成多一次無效處理，但不至於爆炸  
不過程式已在「移除 replied」時呼叫 `heap.remove(id)` 來避免這種情況。

### 10.3 Lazy deletion 會不會讓 heap 一直變大？
deleted 的項目會在它跑到 top 時被清掉。  
在 TTL 會隨時間推進、且 scheduleTimer/peekValid 持續被呼叫的情況下，這個垃圾會自然被清理。

---

# 11) 如果你想，我可以再做兩種加強版模擬

1) **把 heap 當成樹畫出來**（用 index/左右子節點顯示 bubbleUp/sinkDown 的交換）  
2) 模擬「同時很多筆 TTL 到期，但 tab 被 throttling，timer 延遲」時 while-loop 為什麼必要

你想先看哪一種？（或你有指定的 stockId / 流程也可以，我按你的流程跑一次完整狀態表）
