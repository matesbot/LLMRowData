*Thinking...*

> The user wants me to take the final solution I provided and:
> 1. Add detailed comments throughout the code
> 2. Provide an example of how to use it
> 
> Let me recall the final solution and add comprehensive comments explaining every part, then create a practical example showing how to use the hook in a React component.
> 
> I'll structure this with:
> 1. The fully commented hook code
> 2. A complete example React component showing usage
> 3. Maybe some notes on the API
> 
> Let me write this out carefully.

# Complete Solution with Detailed Comments and Usage Example

## Part 1: The Hook (Fully Commented)

```javascript
import { useState, useRef, useCallback, useEffect } from 'react';

// =============================================================================
// LAZY DELETE MIN-HEAP
// =============================================================================
// 
// A min-heap optimized for our TTL (Time-To-Live) use case.
// 
// Traditional heaps have O(log n) removal for arbitrary elements, but require
// tracking indices. This "lazy" approach instead marks items as deleted in O(1),
// and cleans them up only when they reach the top of the heap.
//
// Trade-off: Uses slightly more memory (deleted IDs stay in Set until cleaned),
// but avoids the complexity and overhead of maintaining an index map.
// =============================================================================

class LazyHeap {
    constructor() {
        // The heap array stores objects with { id, expiryTime }
        // Ordered as a min-heap by expiryTime (smallest at top)
        this.heap = [];
        
        // Set of IDs that have been "logically" deleted but may still
        // exist in the heap array. We skip these when peeking/popping.
        this.deleted = new Set();
    }

    /**
     * Add a new TTL entry to the heap.
     * 
     * @param {number|string} id - Unique identifier for the row
     * @param {number} expiryTime - Unix timestamp (ms) when this row should expire
     * 
     * Time Complexity: O(log n)
     */
    push(id, expiryTime) {
        this.heap.push({ id, expiryTime });
        this._bubbleUp(this.heap.length - 1);
    }

    /**
     * Mark an item as deleted. Does NOT immediately remove from heap.
     * The item will be cleaned up when it reaches the top.
     * 
     * @param {number|string} id - The ID to mark as deleted
     * 
     * Time Complexity: O(1)
     * 
     * Why lazy delete?
     * - Immediate removal from a heap requires knowing the item's index
     * - Maintaining an index map adds overhead on every swap operation
     * - For our use case (nâ‰¤300), lazy deletion is simpler and fast enough
     */
    remove(id) {
        this.deleted.add(id);
    }

    /**
     * Get the next valid (non-deleted) item without removing it.
     * Cleans up any deleted items at the top first.
     * 
     * @returns {{ id, expiryTime } | null} The next item to expire, or null if empty
     * 
     * Time Complexity: O(log n) amortized (due to cleanup)
     */
    peekValid() {
        this._cleanTop();
        return this.heap[0] ?? null;
    }

    /**
     * Remove and return the next valid (non-deleted) item.
     * 
     * @returns {{ id, expiryTime } | null} The expired item, or null if empty
     * 
     * Time Complexity: O(log n)
     */
    popValid() {
        this._cleanTop();
        if (this.heap.length === 0) return null;
        return this._pop();
    }

    /**
     * Remove any deleted items from the top of the heap.
     * Called internally before peek/pop operations.
     * 
     * This is where "lazy" deletion actually happens - we only
     * remove deleted items when they bubble up to the top.
     */
    _cleanTop() {
        while (this.heap.length > 0 && this.deleted.has(this.heap[0].id)) {
            // Remove from deleted set (cleanup memory)
            this.deleted.delete(this.heap[0].id);
            // Actually remove from heap
            this._pop();
        }
    }

    /**
     * Internal: Remove and return the top element of the heap.
     * Standard heap pop operation.
     * 
     * Algorithm:
     * 1. Save the top element (minimum)
     * 2. Move the last element to the top
     * 3. "Sink down" the new top to restore heap property
     */
    _pop() {
        if (this.heap.length === 0) return null;
        
        const top = this.heap[0];
        const last = this.heap.pop();
        
        // If there are remaining elements, move last to top and sink down
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._sinkDown(0);
        }
        
        return top;
    }

    /**
     * Internal: Restore heap property by moving an element UP.
     * Used after insertion.
     * 
     * @param {number} i - Index of the element to bubble up
     * 
     * Algorithm:
     * - Compare with parent
     * - If smaller than parent, swap and continue
     * - Stop when heap property is satisfied
     */
    _bubbleUp(i) {
        while (i > 0) {
            // Parent index formula: floor((i - 1) / 2)
            // Using >>> 1 (unsigned right shift) is faster than Math.floor
            const parentIdx = (i - 1) >>> 1;
            
            // If parent is smaller or equal, heap property is satisfied
            if (this.heap[parentIdx].expiryTime <= this.heap[i].expiryTime) break;
            
            // Swap with parent
            [this.heap[parentIdx], this.heap[i]] = [this.heap[i], this.heap[parentIdx]];
            i = parentIdx;
        }
    }

    /**
     * Internal: Restore heap property by moving an element DOWN.
     * Used after removing the top element.
     * 
     * @param {number} i - Index of the element to sink down
     * 
     * Algorithm:
     * - Compare with both children
     * - Swap with the smaller child if it's smaller than current
     * - Continue until heap property is satisfied
     */
    _sinkDown(i) {
        const len = this.heap.length;
        
        while (true) {
            let smallest = i;
            
            // Left child index: 2*i + 1
            const leftIdx = (i << 1) + 1;  // Bit shift is faster than multiplication
            // Right child index: 2*i + 2
            const rightIdx = leftIdx + 1;
            
            // Check if left child is smaller
            if (leftIdx < len && this.heap[leftIdx].expiryTime < this.heap[smallest].expiryTime) {
                smallest = leftIdx;
            }
            
            // Check if right child is smaller
            if (rightIdx < len && this.heap[rightIdx].expiryTime < this.heap[smallest].expiryTime) {
                smallest = rightIdx;
            }
            
            // If current is already the smallest, we're done
            if (smallest === i) break;
            
            // Swap with the smaller child
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}


// =============================================================================
// ID GENERATOR
// =============================================================================
// Simple incrementing ID generator. Using a module-level variable is fine
// because IDs only need to be unique within a session, not across page reloads.
// =============================================================================

let _idCounter = 0;

/**
 * Generate a unique ID for a new row.
 * @returns {number} A unique integer ID
 */
const nextId = () => ++_idCounter;


// =============================================================================
// ROW DATA MANAGER HOOK
// =============================================================================
//
// This hook manages a list of trading order rows with the following features:
//
// 1. FIFO Queue: Maximum 300 rows, oldest removed first when limit exceeded
// 2. Unique Unreplied: Only one unreplied row per stockId (newer replaces older)
// 3. Unique Replied: Only one replied row per stockId (newer replaces older)
// 4. TTL Expiration: Replied rows can auto-expire after a configurable time
//
// Architecture:
// - Mutable refs hold the "source of truth" (fast updates, no React overhead)
// - React state holds a snapshot for rendering (updated via flush())
// - This separation allows complex logic without triggering renders mid-calculation
//
// =============================================================================

/**
 * @param {function} cancelOrder - Callback invoked when a row expires via TTL.
 *                                  Receives the row ID as argument.
 * @returns {object} { rowData, handleMsg, onRowSubmit }
 */
export function useRowDataManager(cancelOrder) {
    
    // =========================================================================
    // MUTABLE REFS (Source of Truth)
    // =========================================================================
    // These hold the actual data and are mutated directly for performance.
    // React doesn't see changes to refs, so we manually "flush" to state.
    // =========================================================================
    
    /**
     * The ordered array of row objects.
     * This is the "display order" - newest items are at the end.
     * Maximum length: 300 (enforced by FIFO eviction)
     */
    const rowsRef = useRef([]);
    
    /**
     * Map: rowId -> row object
     * 
     * Purpose: O(1) lookup of any row by its unique ID.
     * 
     * Why store object references instead of indices?
     * - Indices become stale after splice/shift operations
     * - Object references remain valid until the object is removed
     * - When we need the index, we use indexOf(objectRef) which is fast
     */
    const byIdRef = useRef(new Map());
    
    /**
     * Map: stockId -> row object (unreplied only)
     * 
     * Purpose: Track the current unreplied row for each stock.
     * Constraint: Only ONE unreplied row per stockId at any time.
     * 
     * When a new message arrives for a stock that already has an unreplied row,
     * the old unreplied row is removed and replaced with the new one.
     */
    const unrepliedRef = useRef(new Map());
    
    /**
     * Map: stockId -> row object (replied only)
     * 
     * Purpose: Track the current replied row for each stock.
     * Constraint: Only ONE replied row per stockId at any time.
     * 
     * When a new row is replied for a stock that already has a replied row,
     * the old replied row is removed.
     */
    const repliedRef = useRef(new Map());
    
    /**
     * The TTL (Time-To-Live) heap for auto-expiring replied rows.
     * Min-heap ordered by expiry time - the soonest expiry is always at top.
     */
    const ttlHeapRef = useRef(new LazyHeap());
    
    /**
     * Reference to the current setTimeout timer for TTL processing.
     * We store this so we can cancel and reschedule when the next expiry changes.
     */
    const timerRef = useRef(null);


    // =========================================================================
    // REACT STATE (For Rendering Only)
    // =========================================================================
    
    /**
     * This state holds a COPY of the rows array for React to render.
     * It's updated by flush() after mutable operations complete.
     * 
     * Why separate state from refs?
     * - Refs can be mutated synchronously without triggering renders
     * - We control exactly when React re-renders via flush()
     * - This avoids intermediate renders during complex operations
     */
    const [displayRows, setDisplayRows] = useState([]);


    // =========================================================================
    // HELPER: FLUSH TO REACT
    // =========================================================================
    
    /**
     * Copy the current mutable state to React state, triggering a re-render.
     * 
     * We use slice() to create a new array reference. React uses reference
     * equality to detect changes, so we need a new reference even if the
     * contents are the same.
     */
    const flush = useCallback(() => {
        setDisplayRows(rowsRef.current.slice());
    }, []);


    // =========================================================================
    // TTL (TIME-TO-LIVE) EXPIRATION SYSTEM
    // =========================================================================
    
    /**
     * Schedule a timer for the next TTL expiration.
     * 
     * How it works:
     * 1. Cancel any existing timer
     * 2. Peek at the heap to find the next expiry time
     * 3. Set a timeout for that time
     * 4. When timer fires, processExpiries() handles all due expirations
     * 
     * Why one timer instead of many?
     * - Fewer active timers = better performance
     * - Easier to manage and cancel
     * - Heap always tells us the next expiry
     */
    const scheduleTimer = useCallback(() => {
        // Clear existing timer if any
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }

        // Check if there's anything in the heap
        const next = ttlHeapRef.current.peekValid();
        if (!next) return; // Nothing to schedule

        // Calculate delay (minimum 0 to handle already-expired items)
        const delay = Math.max(0, next.expiryTime - Date.now());
        
        // Schedule the processing
        timerRef.current = setTimeout(processExpiries, delay);
    }, []);

    /**
     * Process all rows that have reached their TTL expiration.
     * 
     * This function:
     * 1. Pops all expired items from the heap
     * 2. Removes them from all data structures
     * 3. Calls cancelOrder() for each expired row
     * 4. Flushes changes to React
     * 5. Schedules the next timer
     * 
     * Why a loop instead of just one?
     * - Multiple items might expire at the same time (same TTL)
     * - Timer might fire late, missing some expirations
     */
    const processExpiries = useCallback(() => {
        const now = Date.now();
        const heap = ttlHeapRef.current;
        const rows = rowsRef.current;
        let changed = false;

        // Keep processing while there are expired items
        while (true) {
            const next = heap.peekValid();
            
            // Stop if heap is empty or next item hasn't expired yet
            if (!next || next.expiryTime > now) break;

            // Remove from heap
            heap.popValid();
            
            // Find the row object
            const row = byIdRef.current.get(next.id);
            
            // Row might already be removed (e.g., by FIFO eviction)
            if (row) {
                // Notify external system about cancellation
                cancelOrder(row.id);

                // Remove from main array
                // indexOf on object reference is O(n) but fast for n=300
                const idx = rows.indexOf(row);
                if (idx !== -1) {
                    rows.splice(idx, 1);
                }

                // Clean up Maps
                byIdRef.current.delete(row.id);
                
                // Only delete from repliedRef if this row is still the current replied
                // (might have been replaced by another row)
                if (repliedRef.current.get(row.stockId) === row) {
                    repliedRef.current.delete(row.stockId);
                }
                
                changed = true;
            }
        }

        // Only re-render if something actually changed
        if (changed) {
            flush();
        }
        
        // Schedule timer for next expiration
        scheduleTimer();
    }, [cancelOrder, flush, scheduleTimer]);


    // =========================================================================
    // MAIN API: handleMsg
    // =========================================================================
    
    /**
     * Handle an incoming message (new unreplied row).
     * 
     * Business Logic:
     * 1. If there's already an unreplied row for this stock, remove it
     * 2. Create a new row from the message
     * 3. Add to the end of the list (FIFO order)
     * 4. If list exceeds 300, remove oldest items
     * 
     * @param {object} msg - The incoming message
     * @param {number} msg.time - Timestamp of the message
     * @param {string} msg.stockId - Stock identifier
     * @param {string} [msg.stockName] - Optional stock name
     * @param {any} [...] - Any other fields to include in the row
     */
    const handleMsg = useCallback((msg) => {
        const { time, stockId } = msg;
        
        // Get references to our mutable data structures
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;

        // ---------------------------------------------------------------------
        // Step 1: Remove existing unreplied row for this stock (if any)
        // ---------------------------------------------------------------------
        // Business rule: Only one unreplied row per stock at a time.
        // The new message "replaces" any pending unreplied message.
        
        const oldUnreplied = unreplied.get(stockId);
        
        if (oldUnreplied) {
            // Find index in array using object reference
            const idx = rows.indexOf(oldUnreplied);
            
            if (idx !== -1) {
                // Native splice: removes element and shifts remaining elements
                // O(n) but very fast in practice for n=300
                rows.splice(idx, 1);
            }
            
            // Clean up Maps
            byId.delete(oldUnreplied.id);
            unreplied.delete(stockId);
        }

        // ---------------------------------------------------------------------
        // Step 2: Create and add the new row
        // ---------------------------------------------------------------------
        
        const newRow = {
            id: nextId(),           // Unique identifier
            time,                   // Message timestamp
            stockId,                // Stock identifier
            stockName: msg.stockName || null,  // Optional stock name
            repliedTime: null,      // null = unreplied, timestamp = replied
            qty: null,              // Filled when replied
            price: null,            // Filled when replied
            // Spread any additional fields from the message
            ...Object.fromEntries(
                Object.entries(msg).filter(([k]) => 
                    !['time', 'stockId', 'stockName'].includes(k)
                )
            )
        };

        // Add to end of array (FIFO: newest at end)
        rows.push(newRow);
        
        // Add to lookup Maps
        byId.set(newRow.id, newRow);
        unreplied.set(stockId, newRow);

        // ---------------------------------------------------------------------
        // Step 3: Enforce maximum capacity (FIFO eviction)
        // ---------------------------------------------------------------------
        // If we exceed 300 rows, remove the oldest (from the front)
        
        while (rows.length > 300) {
            // shift() removes and returns the first element
            const removed = rows.shift();
            
            // Clean up byId Map
            byId.delete(removed.id);

            // Clean up unreplied Map if this was the unreplied row for its stock
            if (unreplied.get(removed.stockId) === removed) {
                unreplied.delete(removed.stockId);
            }
            
            // Clean up replied Map and TTL heap if this was a replied row
            if (replied.get(removed.stockId) === removed) {
                replied.delete(removed.stockId);
                // Lazy delete from heap - O(1), cleaned up later
                ttlHeapRef.current.remove(removed.id);
            }
        }

        // ---------------------------------------------------------------------
        // Step 4: Update React state
        // ---------------------------------------------------------------------
        flush();
        
    }, [flush]);


    // =========================================================================
    // MAIN API: onRowSubmit
    // =========================================================================
    
    /**
     * Handle a row submission (user replies to an unreplied row).
     * 
     * Business Logic:
     * 1. Find the row by ID and verify it's unreplied
     * 2. If there's already a replied row for this stock, remove it
     * 3. Update the row with reply data (mutate in place)
     * 4. Move from unreplied tracking to replied tracking
     * 5. Set up TTL expiration if specified
     * 
     * @param {object} submission - The submission data
     * @param {number} submission.id - ID of the row being replied to
     * @param {number} submission.qty - Quantity for the reply
     * @param {number} submission.price - Price for the reply
     * @param {number} [submission.ttl=0] - Time-to-live in seconds (0 = no expiry)
     * @param {boolean} [submission.isExpiry=false] - If true, skip TTL setup
     */
    const onRowSubmit = useCallback((submission) => {
        const { id, qty, price, ttl = 0, isExpiry = false } = submission;
        
        // Get references to our mutable data structures
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;
        const heap = ttlHeapRef.current;

        // ---------------------------------------------------------------------
        // Step 1: Find and validate the row
        // ---------------------------------------------------------------------
        
        const row = byId.get(id);
        
        // Guard: Row doesn't exist
        if (!row) {
            console.warn(`onRowSubmit: Row with id ${id} not found`);
            return;
        }
        
        // Guard: Row already replied (can't reply twice)
        if (row.repliedTime) {
            console.warn(`onRowSubmit: Row ${id} already replied`);
            return;
        }

        const stockId = row.stockId;

        // ---------------------------------------------------------------------
        // Step 2: Remove existing replied row for this stock (if any)
        // ---------------------------------------------------------------------
        // Business rule: Only one replied row per stock at a time.
        
        const oldReplied = replied.get(stockId);
        
        if (oldReplied && oldReplied !== row) {
            // Find and remove from array
            const idx = rows.indexOf(oldReplied);
            if (idx !== -1) {
                rows.splice(idx, 1);
            }
            
            // Clean up Maps
            byId.delete(oldReplied.id);
            replied.delete(stockId);
            
            // Cancel its TTL (lazy delete)
            heap.remove(oldReplied.id);
        }

        // ---------------------------------------------------------------------
        // Step 3: Update the row in place
        // ---------------------------------------------------------------------
        // We mutate the existing object rather than creating a new one.
        // This is safe because:
        // - We'll flush to React with a new array reference
        // - The object identity is preserved in our Maps
        
        row.repliedTime = Date.now();
        row.qty = qty;
        row.price = price;

        // ---------------------------------------------------------------------
        // Step 4: Update tracking Maps
        // ---------------------------------------------------------------------
        
        // No longer unreplied
        unreplied.delete(stockId);
        
        // Now replied
        replied.set(stockId, row);

        // ---------------------------------------------------------------------
        // Step 5: Set up TTL if specified
        // ---------------------------------------------------------------------
        
        if (!isExpiry && ttl > 0) {
            // Calculate expiry time
            const expiryTime = Date.now() + ttl * 1000;
            
            // Add to TTL heap
            heap.push(id, expiryTime);
            
            // Schedule/reschedule the timer
            scheduleTimer();
        }

        // ---------------------------------------------------------------------
        // Step 6: Update React state
        // ---------------------------------------------------------------------
        flush();
        
    }, [flush, scheduleTimer]);


    // =========================================================================
    // CLEANUP
    // =========================================================================
    
    /**
     * Clean up timer on unmount.
     * This prevents memory leaks and errors from callbacks firing
     * after the component is gone.
     */
    useEffect(() => {
        return () => {
            if (timerRef.current) {
                clearTimeout(timerRef.current);
            }
        };
    }, []);


    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================
    
    return {
        /**
         * The current array of rows for rendering.
         * This is a shallow copy of the internal array, safe to render.
         * @type {Array<object>}
         */
        rowData: displayRows,
        
        /**
         * Handle an incoming message (creates new unreplied row).
         * @type {function}
         */
        handleMsg,
        
        /**
         * Handle a row submission (marks row as replied).
         * @type {function}
         */
        onRowSubmit
    };
}
```

---

## Part 2: Usage Example

```jsx type=react
import React, { useState, useRef, useCallback, useEffect } from 'react';
import { Play, Pause, Send, Clock, Trash2, AlertCircle } from 'lucide-react';

// =============================================================================
// LAZY HEAP IMPLEMENTATION (Same as above, included for completeness)
// =============================================================================

class LazyHeap {
    constructor() {
        this.heap = [];
        this.deleted = new Set();
    }

    push(id, expiryTime) {
        this.heap.push({ id, expiryTime });
        this._bubbleUp(this.heap.length - 1);
    }

    remove(id) {
        this.deleted.add(id);
    }

    peekValid() {
        this._cleanTop();
        return this.heap[0] ?? null;
    }

    popValid() {
        this._cleanTop();
        if (this.heap.length === 0) return null;
        return this._pop();
    }

    _cleanTop() {
        while (this.heap.length > 0 && this.deleted.has(this.heap[0].id)) {
            this.deleted.delete(this.heap[0].id);
            this._pop();
        }
    }

    _pop() {
        if (this.heap.length === 0) return null;
        const top = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._sinkDown(0);
        }
        return top;
    }

    _bubbleUp(i) {
        while (i > 0) {
            const p = (i - 1) >>> 1;
            if (this.heap[p].expiryTime <= this.heap[i].expiryTime) break;
            [this.heap[p], this.heap[i]] = [this.heap[i], this.heap[p]];
            i = p;
        }
    }

    _sinkDown(i) {
        const len = this.heap.length;
        while (true) {
            let smallest = i;
            const l = (i << 1) + 1;
            const r = l + 1;
            if (l < len && this.heap[l].expiryTime < this.heap[smallest].expiryTime) smallest = l;
            if (r < len && this.heap[r].expiryTime < this.heap[smallest].expiryTime) smallest = r;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

// =============================================================================
// ID GENERATOR
// =============================================================================

let _idCounter = 0;
const nextId = () => ++_idCounter;

// =============================================================================
// THE HOOK
// =============================================================================

function useRowDataManager(cancelOrder) {
    const rowsRef = useRef([]);
    const byIdRef = useRef(new Map());
    const unrepliedRef = useRef(new Map());
    const repliedRef = useRef(new Map());
    const ttlHeapRef = useRef(new LazyHeap());
    const timerRef = useRef(null);

    const [displayRows, setDisplayRows] = useState([]);

    const flush = useCallback(() => {
        setDisplayRows(rowsRef.current.slice());
    }, []);

    const scheduleTimer = useCallback(() => {
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }
        const next = ttlHeapRef.current.peekValid();
        if (!next) return;
        const delay = Math.max(0, next.expiryTime - Date.now());
        timerRef.current = setTimeout(processExpiries, delay);
    }, []);

    const processExpiries = useCallback(() => {
        const now = Date.now();
        const heap = ttlHeapRef.current;
        const rows = rowsRef.current;
        let changed = false;

        while (true) {
            const next = heap.peekValid();
            if (!next || next.expiryTime > now) break;
            heap.popValid();
            const row = byIdRef.current.get(next.id);
            if (row) {
                cancelOrder(row.id);
                const idx = rows.indexOf(row);
                if (idx !== -1) rows.splice(idx, 1);
                byIdRef.current.delete(row.id);
                if (repliedRef.current.get(row.stockId) === row) {
                    repliedRef.current.delete(row.stockId);
                }
                changed = true;
            }
        }

        if (changed) flush();
        scheduleTimer();
    }, [cancelOrder, flush, scheduleTimer]);

    const handleMsg = useCallback((msg) => {
        const { time, stockId, stockName } = msg;
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;

        const oldUnreplied = unreplied.get(stockId);
        if (oldUnreplied) {
            const idx = rows.indexOf(oldUnreplied);
            if (idx !== -1) rows.splice(idx, 1);
            byId.delete(oldUnreplied.id);
            unreplied.delete(stockId);
        }

        const newRow = {
            id: nextId(),
            time,
            stockId,
            stockName: stockName || stockId,
            repliedTime: null,
            qty: null,
            price: null
        };

        rows.push(newRow);
        byId.set(newRow.id, newRow);
        unreplied.set(stockId, newRow);

        while (rows.length > 300) {
            const removed = rows.shift();
            byId.delete(removed.id);
            if (unreplied.get(removed.stockId) === removed) {
                unreplied.delete(removed.stockId);
            }
            if (replied.get(removed.stockId) === removed) {
                replied.delete(removed.stockId);
                ttlHeapRef.current.remove(removed.id);
            }
        }

        flush();
    }, [flush]);

    const onRowSubmit = useCallback((submission) => {
        const { id, qty, price, ttl = 0, isExpiry = false } = submission;
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;
        const heap = ttlHeapRef.current;

        const row = byId.get(id);
        if (!row || row.repliedTime) return;

        const stockId = row.stockId;
        const oldReplied = replied.get(stockId);
        if (oldReplied && oldReplied !== row) {
            const idx = rows.indexOf(oldReplied);
            if (idx !== -1) rows.splice(idx, 1);
            byId.delete(oldReplied.id);
            replied.delete(stockId);
            heap.remove(oldReplied.id);
        }

        row.repliedTime = Date.now();
        row.qty = qty;
        row.price = price;

        unreplied.delete(stockId);
        replied.set(stockId, row);

        if (!isExpiry && ttl > 0) {
            heap.push(id, Date.now() + ttl * 1000);
            scheduleTimer();
        }

        flush();
    }, [flush, scheduleTimer]);

    useEffect(() => {
        return () => {
            if (timerRef.current) clearTimeout(timerRef.current);
        };
    }, []);

    return { rowData: displayRows, handleMsg, onRowSubmit };
}

// =============================================================================
// DEMO COMPONENT
// =============================================================================

const STOCKS = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'JPM'];

export default function TradingDemo() {
    const [isSimulating, setIsSimulating] = useState(false);
    const [logs, setLogs] = useState([]);
    const [ttl, setTtl] = useState(5);
    const intervalRef = useRef(null);

    // Log helper
    const addLog = useCallback((message, type = 'info') => {
        setLogs(prev => [...prev.slice(-19), { message, type, time: new Date().toLocaleTimeString() }]);
    }, []);

    // Callback when a row expires
    const handleCancelOrder = useCallback((id) => {
        addLog(`Order #${id} expired and cancelled`, 'warning');
    }, [addLog]);

    // Initialize the hook
    const { rowData, handleMsg, onRowSubmit } = useRowDataManager(handleCancelOrder);

    // Simulate incoming messages
    const simulateMessage = useCallback(() => {
        const stockId = STOCKS[Math.floor(Math.random() * STOCKS.length)];
        const msg = {
            time: Date.now(),
            stockId,
            stockName: stockId + ' Inc.'
        };
        handleMsg(msg);
        addLog(`New order received for ${stockId}`, 'info');
    }, [handleMsg, addLog]);

    // Toggle simulation
    const toggleSimulation = () => {
        if (isSimulating) {
            clearInterval(intervalRef.current);
            addLog('Simulation stopped', 'info');
        } else {
            intervalRef.current = setInterval(simulateMessage, 1000);
            addLog('Simulation started (1 msg/sec)', 'info');
        }
        setIsSimulating(!isSimulating);
    };

    // Handle row reply
    const handleReply = (row) => {
        const qty = Math.floor(Math.random() * 1000) + 100;
        const price = (Math.random() * 500 + 50).toFixed(2);
        
        onRowSubmit({
            id: row.id,
            qty,
            price: parseFloat(price),
            ttl
        });
        
        addLog(`Replied to ${row.stockId}: ${qty} @ $${price} (TTL: ${ttl}s)`, 'success');
    };

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, []);

    // Stats
    const unrepliedCount = rowData.filter(r => !r.repliedTime).length;
    const repliedCount = rowData.filter(r => r.repliedTime).length;

    return (
        <div className="min-h-screen bg-gray-900 text-white p-4">
            <div className="max-w-6xl mx-auto space-y-4">
                {/* Header */}
                <div className="flex items-center justify-between">
                    <h1 className="text-2xl font-bold">Trading Row Manager Demo</h1>
                    <div className="flex items-center gap-4">
                        <div className="flex items-center gap-2">
                            <Clock className="w-4 h-4" />
                            <span className="text-sm">TTL:</span>
                            <input
                                type="number"
                                value={ttl}
                                onChange={(e) => setTtl(Math.max(1, parseInt(e.target.value) || 1))}
                                className="w-16 bg-gray-800 rounded px-2 py-1 text-sm"
                            />
                            <span className="text-sm text-gray-400">seconds</span>
                        </div>
                        <button
                            onClick={toggleSimulation}
                            className={`flex items-center gap-2 px-4 py-2 rounded font-medium ${
                                isSimulating ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                            }`}
                        >
                            {isSimulating ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
                            {isSimulating ? 'Stop' : 'Start'} Simulation
                        </button>
                        <button
                            onClick={simulateMessage}
                            className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-medium"
                        >
                            <Send className="w-4 h-4" />
                            Add Message
                        </button>
                    </div>
                </div>

                {/* Stats */}
                <div className="flex gap-4">
                    <div className="bg-gray-800 rounded-lg px-4 py-2">
                        <span className="text-gray-400">Total:</span>
                        <span className="ml-2 font-bold">{rowData.length}</span>
                    </div>
                    <div className="bg-yellow-900/50 rounded-lg px-4 py-2">
                        <span className="text-yellow-400">Unreplied:</span>
                        <span className="ml-2 font-bold">{unrepliedCount}</span>
                    </div>
                    <div className="bg-green-900/50 rounded-lg px-4 py-2">
                        <span className="text-green-400">Replied:</span>
                        <span className="ml-2 font-bold">{repliedCount}</span>
                    </div>
                </div>

                {/* Main Content */}
                <div className="grid grid-cols-3 gap-4">
                    {/* Orders Table */}
                    <div className="col-span-2 bg-gray-800 rounded-lg overflow-hidden">
                        <div className="p-3 bg-gray-700 font-semibold">Orders</div>
                        <div className="max-h-96 overflow-auto">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-700/50 sticky top-0">
                                    <tr>
                                        <th className="px-3 py-2 text-left">ID</th>
                                        <th className="px-3 py-2 text-left">Stock</th>
                                        <th className="px-3 py-2 text-left">Status</th>
                                        <th className="px-3 py-2 text-right">Qty</th>
                                        <th className="px-3 py-2 text-right">Price</th>
                                        <th className="px-3 py-2 text-center">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {rowData.length === 0 ? (
                                        <tr>
                                            <td colSpan={6} className="px-3 py-8 text-center text-gray-500">
                                                No orders yet. Click "Add Message" or "Start Simulation"
                                            </td>
                                        </tr>
                                    ) : (
                                        rowData.map(row => (
                                            <tr key={row.id} className="border-t border-gray-700 hover:bg-gray-700/50">
                                                <td className="px-3 py-2 font-mono text-gray-400">#{row.id}</td>
                                                <td className="px-3 py-2 font-medium">{row.stockId}</td>
                                                <td className="px-3 py-2">
                                                    {row.repliedTime ? (
                                                        <span className="text-green-400 text-xs bg-green-900/30 px-2 py-0.5 rounded">
                                                            Replied
                                                        </span>
                                                    ) : (
                                                        <span className="text-yellow-400 text-xs bg-yellow-900/30 px-2 py-0.5 rounded">
                                                            Pending
                                                        </span>
                                                    )}
                                                </td>
                                                <td className="px-3 py-2 text-right font-mono">
                                                    {row.qty ?? '-'}
                                                </td>
                                                <td className="px-3 py-2 text-right font-mono">
                                                    {row.price ? `$${row.price.toFixed(2)}` : '-'}
                                                </td>
                                                <td className="px-3 py-2 text-center">
                                                    {!row.repliedTime && (
                                                        <button
                                                            onClick={() => handleReply(row)}
                                                            className="text-blue-400 hover:text-blue-300 text-xs"
                                                        >
                                                            Reply
                                                        </button>
                                                    )}
                                                </td>
                                            </tr>
                                        ))
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    {/* Logs */}
                    <div className="bg-gray-800 rounded-lg overflow-hidden">
                        <div className="p-3 bg-gray-700 font-semibold flex items-center gap-2">
                            <AlertCircle className="w-4 h-4" />
                            Activity Log
                        </div>
                        <div className="max-h-96 overflow-auto p-2 space-y-1">
                            {logs.length === 0 ? (
                                <div className="text-gray-500 text-sm text-center py-4">
                                    No activity yet
                                </div>
                            ) : (
                                logs.map((log, i) => (
                                    <div
                                        key={i}
                                        className={`text-xs p-2 rounded ${
                                            log.type === 'warning' ? 'bg-yellow-900/30 text-yellow-300' :
                                            log.type === 'success' ? 'bg-green-900/30 text-green-300' :
                                            'bg-gray-700/50 text-gray-300'
                                        }`}
                                    >
                                        <span className="text-gray-500">{log.time}</span>
                                        <span className="ml-2">{log.message}</span>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>

                {/* Instructions */}
                <div className="bg-gray-800/50 rounded-lg p-4 text-sm text-gray-400">
                    <p className="font-medium text-gray-300 mb-2">How to test:</p>
                    <ul className="list-disc list-inside space-y-1">
                        <li>Click <strong>Add Message</strong> to add a single unreplied order</li>
                        <li>Click <strong>Start Simulation</strong> to auto-add orders every second</li>
                        <li>Click <strong>Reply</strong> on any pending order to mark it as replied (with TTL)</li>
                        <li>Watch replied orders auto-expire after the TTL (default 5 seconds)</li>
                        <li>Notice: Only one unreplied + one replied row per stock (duplicates are removed)</li>
                    </ul>
                </div>
            </div>
        </div>
    );
}
```

---

## Quick Reference

| Function | Purpose | When to Call |
|----------|---------|--------------|
| `handleMsg(msg)` | Add a new unreplied row | When a new order/message arrives from the server |
| `onRowSubmit(submission)` | Mark a row as replied with data | When user submits a response to an order |
| `rowData` | Array of rows for rendering | Use in your JSX to render the table |

### Message Format

```javascript
handleMsg({
    time: Date.now(),      // Required: timestamp
    stockId: 'AAPL',       // Required: unique stock identifier
    stockName: 'Apple',    // Optional: display name
    // ...any other fields you want to include
});
```

### Submission Format

```javascript
onRowSubmit({
    id: 123,              // Required: row ID to reply to
    qty: 500,             // Required: quantity
    price: 150.50,        // Required: price
    ttl: 10,              // Optional: seconds until auto-expire (0 = never)
    isExpiry: false       // Optional: skip TTL if true
});
```