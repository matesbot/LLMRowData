*Thinking...*

> The user is sharing feedback from another AI that claims my optimized solution is still slower than a "mutable ref" approach. Let me analyze this critique carefully.
> 
> The other AI makes several claims:
> 
> 1. **"Fake" Optimization** - Claims I'm not using the index map for O(1) removal
> 2. **Manual JS Loops vs Native Methods** - Claims my for loops are slower than native methods
> 3. **rebuildIndexMap Overhead** - Claims I iterate twice per message
> 4. **Heap Overhead** - Claims IndexedExpiryHeap has too much overhead for N=300
> 5. **React Render Cycle Coupling** - Claims doing logic inside setRowData is slower
> 
> Let me evaluate each claim:
> 
> ### Claim 1: Not using the index map
> This is partially true - I do have an index map but in the handleMsg I'm doing a filter loop anyway. However, the reason is that after removal, indices shift, so you'd need to rebuild anyway OR use a different data structure.
> 
> ### Claim 2: Manual loops vs native methods
> This is a nuanced claim:
> - `splice` is O(n) for shifting elements
> - A manual filter loop is also O(n)
> - The claim that `splice` is faster because it's "native C++" is somewhat true but overstated for n=300
> 
> ### Claim 3: rebuildIndexMap overhead
> This is a valid critique - I do rebuild the index map after every operation, which is O(n) overhead.
> 
> ### Claim 4: Heap overhead for small N
> This is actually a good point. For N=300, the overhead of maintaining an indexed heap might not be worth it compared to simpler approaches.
> 
> ### Claim 5: React render cycle coupling
> This is partially valid - doing heavy logic inside setRowData means it runs during React's update cycle.
> 
> However, the other AI's proposed solution also has issues:
> 
> 1. Their code snippet is incomplete and has bugs:
> ```javascript
> const existingIdx = map.get(msg.stockId);
> 
> 
> if (existingIdx !== undefined) {
>     rows.splice(existingIdx, 1);
>     map.delete(msg.stockId);
>     // Note: When splicing, you must update indices in Map for all items after.
> ```
> They acknowledge the index map becomes invalid after splice but don't fix it!
> 
> 2. They claim `[...rows]` spread is faster than a for loop with push, but this depends on the engine and use case.
> 
> 3. They mention "Lazy Delete" for the heap but don't implement it.
> 
> The core issue with their approach is that splice invalidates the index map for all subsequent elements, requiring a full rebuild anyway. For N=300, the algorithmic complexity matters less than implementation overhead, so I should focus on a simpler, more direct solution that avoids unnecessary data structure complexity while still maintaining correctness.
> 
> A better approach would use mutable refs as the source of truth with a Map for O(1) lookups, a plain array for ordering, and lazy deletion on the TTL heap. This avoids index tracking entirely and batches state updates to minimize React re-renders.

# Fair Analysis: The Other AI Makes Valid Points

Let me be honest—several of those critiques are legitimate. Here's my breakdown:

## Valid Criticisms ✓

### 1. Unused Index Map
The other AI is correct. I created `rowIndexByIdRef` but then did a filter loop anyway:

```javascript
// I wrote this, which defeats the purpose of the index map
for (let i = 0; i < prev.length; i++) {
    if (prev[i].id !== existingUnrepliedId) {
        next.push(prev[i]);
    }
}
```

### 2. Double Iteration
Calling `rebuildIndexMap(next)` after every operation adds O(n) overhead unnecessarily.

### 3. Logic Inside `setRowData`
Running complex logic inside the state updater function does couple it to React's render cycle.

### 4. Heap Overhead for Small N
For n=300, the constant overhead of maintaining `indexMap` in the heap (updating on every swap) may exceed the benefit of O(log n) removal.

---

## Where the Other AI Is Wrong or Incomplete

### 1. Their Code Has a Critical Bug

```javascript
const existingIdx = map.get(msg.stockId);
if (existingIdx !== undefined) {
    rows.splice(existingIdx, 1);
    map.delete(msg.stockId);
    // They admit: "When splicing, you must update indices in Map for all items after"
    // But they don't actually fix it!
}
```

After `splice`, every index after the removed element is now wrong. They acknowledge this but leave it broken.

### 2. "Native C++ splice" Misconception

`splice` is still O(n) because it shifts all subsequent elements. The "native C++" argument is about constant factors, which matter, but it's not a complexity improvement.

### 3. Their "Lazy Delete" Heap Isn't Implemented

They mention lazy deletion but don't show how to handle the case where a lazily-deleted item needs to be actively removed (e.g., when the row is replaced by a new reply).

---

## The Actually Fastest Implementation

Here's a properly optimized version that addresses all concerns:

```javascript
import { useState, useRef, useCallback, useEffect } from 'react';

// --- Lazy Delete MinHeap (No index tracking overhead) ---
class LazyHeap {
    constructor() {
        this.heap = [];
        this.deleted = new Set();
    }

    push(id, expiryTime) {
        this.heap.push({ id, expiryTime });
        this._bubbleUp(this.heap.length - 1);
    }

    // O(1) - just mark as deleted
    remove(id) {
        this.deleted.add(id);
    }

    // Peek, skipping deleted items
    peekValid() {
        this._cleanTop();
        return this.heap[0] ?? null;
    }

    // Pop, skipping deleted items
    popValid() {
        this._cleanTop();
        if (this.heap.length === 0) return null;
        return this._pop();
    }

    _cleanTop() {
        while (this.heap.length > 0 && this.deleted.has(this.heap[0].id)) {
            this.deleted.delete(this.heap[0].id);
            this._pop();
        }
    }

    _pop() {
        if (this.heap.length === 0) return null;
        const top = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._sinkDown(0);
        }
        return top;
    }

    _bubbleUp(i) {
        while (i > 0) {
            const p = (i - 1) >>> 1;
            if (this.heap[p].expiryTime <= this.heap[i].expiryTime) break;
            [this.heap[p], this.heap[i]] = [this.heap[i], this.heap[p]];
            i = p;
        }
    }

    _sinkDown(i) {
        const len = this.heap.length;
        while (true) {
            let smallest = i;
            const l = (i << 1) + 1;
            const r = l + 1;
            if (l < len && this.heap[l].expiryTime < this.heap[smallest].expiryTime) smallest = l;
            if (r < len && this.heap[r].expiryTime < this.heap[smallest].expiryTime) smallest = r;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

// --- Fast ID generator ---
let _id = 0;
const nextId = () => ++_id;

export function useRowDataManager(cancelOrder) {
    // === MUTABLE STATE (Source of Truth) ===
    const rowsRef = useRef([]);                    // Ordered array of row objects
    const byIdRef = useRef(new Map());             // id -> row object (NOT index!)
    const unrepliedRef = useRef(new Map());        // stockId -> row object
    const repliedRef = useRef(new Map());          // stockId -> row object
    const ttlHeapRef = useRef(new LazyHeap());
    const timerRef = useRef(null);

    // === REACT STATE (Display Only) ===
    const [displayRows, setDisplayRows] = useState([]);

    // --- Flush mutable state to React ---
    const flush = useCallback(() => {
        // Shallow copy for React's reference check
        setDisplayRows(rowsRef.current.slice());
    }, []);

    // --- TTL Timer ---
    const scheduleTimer = useCallback(() => {
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }

        const next = ttlHeapRef.current.peekValid();
        if (!next) return;

        const delay = Math.max(0, next.expiryTime - Date.now());
        timerRef.current = setTimeout(processExpiries, delay);
    }, []);

    const processExpiries = useCallback(() => {
        const now = Date.now();
        const heap = ttlHeapRef.current;
        const rows = rowsRef.current;
        let changed = false;

        while (true) {
            const next = heap.peekValid();
            if (!next || next.expiryTime > now) break;

            heap.popValid();
            const row = byIdRef.current.get(next.id);
            
            if (row) {
                cancelOrder(row.id);

                // Remove from array (find index, splice)
                const idx = rows.indexOf(row);
                if (idx !== -1) rows.splice(idx, 1);

                // Clean maps
                byIdRef.current.delete(row.id);
                if (repliedRef.current.get(row.stockId) === row) {
                    repliedRef.current.delete(row.stockId);
                }
                changed = true;
            }
        }

        if (changed) flush();
        scheduleTimer();
    }, [cancelOrder, flush, scheduleTimer]);

    // --- Handle Incoming Message ---
    const handleMsg = useCallback((msg) => {
        const { time, stockId } = msg;
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;

        // 1. Remove existing unreplied for this stock (if any)
        const oldUnreplied = unreplied.get(stockId);
        if (oldUnreplied) {
            const idx = rows.indexOf(oldUnreplied); // O(n) but on object reference
            if (idx !== -1) rows.splice(idx, 1);    // Native splice
            byId.delete(oldUnreplied.id);
            unreplied.delete(stockId);
        }

        // 2. Create new row
        const newRow = {
            id: nextId(),
            time,
            stockId,
            repliedTime: null,
            qty: null,
            price: null
        };

        // 3. Add to structures
        rows.push(newRow);
        byId.set(newRow.id, newRow);
        unreplied.set(stockId, newRow);

        // 4. FIFO constraint (max 300)
        while (rows.length > 300) {
            const removed = rows.shift();
            byId.delete(removed.id);

            if (unreplied.get(removed.stockId) === removed) {
                unreplied.delete(removed.stockId);
            }
            if (replied.get(removed.stockId) === removed) {
                replied.delete(removed.stockId);
                ttlHeapRef.current.remove(removed.id); // O(1) lazy delete
            }
        }

        // 5. Flush to React
        flush();
    }, [flush]);

    // --- Handle Row Submit ---
    const onRowSubmit = useCallback((submission) => {
        const { id, qty, price, ttl, isExpiry } = submission;
        const rows = rowsRef.current;
        const byId = byIdRef.current;
        const unreplied = unrepliedRef.current;
        const replied = repliedRef.current;
        const heap = ttlHeapRef.current;

        const row = byId.get(id);
        if (!row || row.repliedTime) return; // Already replied or doesn't exist

        const stockId = row.stockId;

        // 1. Remove existing replied for this stock
        const oldReplied = replied.get(stockId);
        if (oldReplied && oldReplied !== row) {
            const idx = rows.indexOf(oldReplied);
            if (idx !== -1) rows.splice(idx, 1);
            byId.delete(oldReplied.id);
            heap.remove(oldReplied.id); // O(1) lazy delete
        }

        // 2. Update row in place (mutate!)
        row.repliedTime = Date.now();
        row.qty = qty;
        row.price = price;

        // 3. Update tracking maps
        unreplied.delete(stockId);
        replied.set(stockId, row);

        // 4. Set TTL if needed
        if (!isExpiry && ttl > 0) {
            heap.push(id, Date.now() + ttl * 1000);
            scheduleTimer();
        }

        // 5. Flush to React
        flush();
    }, [flush, scheduleTimer]);

    // Cleanup
    useEffect(() => {
        return () => {
            if (timerRef.current) clearTimeout(timerRef.current);
        };
    }, []);

    return { rowData: displayRows, handleMsg, onRowSubmit };
}
```

---

## Why This Is Actually Fast

| Aspect | My Previous Code | Other AI's Sketch | This Version |
|--------|------------------|-------------------|--------------|
| Row lookup | O(n) findIndex | Broken index map | O(1) Map → object ref |
| Row removal | O(n) filter loop | O(n) splice (but invalid indices) | O(n) indexOf + splice (but on refs) |
| Index maintenance | O(n) rebuild every time | ❌ Broken | ✅ None needed (use refs) |
| TTL removal | O(log n) indexed heap | ❌ Not implemented | O(1) lazy delete |
| Logic location | Inside setRowData | In refs ✓ | In refs ✓ |
| React updates | Coupled to logic | Decoupled ✓ | Decoupled ✓ |

### The Key Insight

Store **object references** in Maps, not indices. Then:
- Lookup: `map.get(id)` → O(1) returns the actual object
- Find index when needed: `array.indexOf(objectRef)` → Still O(n), but:
  - No stale index problem
  - Native `indexOf` on object identity is very fast
  - Only done when actually removing

For n=300, `indexOf` on object references is ~microseconds. The savings from avoiding index rebuilds and using lazy heap deletion far outweigh this.

---

## Honest Verdict

The other AI's critique was largely valid. My "optimized" solution was over-engineered in the wrong places. This new version should be genuinely fast for the use case.