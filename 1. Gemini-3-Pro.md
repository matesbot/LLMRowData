*Thinking...*

> **Examining the Core Logic**
> 
> I've been drilling down on the fundamental elements. Specifically, the `rowData` array and its FIFO nature. I'm focusing now on the WebSocket input, `handleMsg(msg)`, and how it feeds into the core data structure. Considerations include efficient insertion and removal of elements within the size constraints.
> 
> 
> **Defining Data Flow and Rules**
> 
> I am currently dissecting the implications of the constraints. I'm focusing on the interaction between `handleMsg(msg)` and the `rowData` array. My key concern involves the "max 2 rows per `stockId`" rule, particularly how it affects the replacement of existing rows when new messages arrive. I am also determining how to manage expiry times (`ttl`) efficiently.
> 
> 
> **Optimizing for Speed and Scale**
> 
> I'm now zeroing in on optimizing data management. The primary focus is eliminating array copies and reducing the search complexity for `stockId` rows. Using `useRef` to manage the underlying data and employing a `Map` structure for `stockId` lookups seems promising. I am evaluating various strategies for TTL handling, including a priority queue to minimize `setTimeout` usage.
> 
> 
> **Formulating a Concrete Design**
> 
> I'm now fully immersed in the design phase. I've opted for a `Map` structure indexed by `stockId` that points to an object containing references (IDs) for unreplied and replied rows in the `rowData` array. This should drastically improve lookup times. Next, I am formalizing the `handleMsg` logic, including the interaction with the aforementioned `Map`.
> 
> 
> **Defining the Core Structures**
> 
> I'm solidifying the data structures now. I'll maintain a `rowData` array for React's display. Complementing this, a `Map` will efficiently store `stockId` associations to row IDs (unreplied and replied), crucial for fast lookups. The TTL management will lean towards a min-heap structure for optimized expiry processing.
> 
> 
> **Structuring the Core Components**
> 
> I'm presently building the `useStockTable` hook and defining the data structures. The plan is to have a `rowsRef` array (mutable for data processing), a `stockIndex` (Map for stockId lookups), and an `expiryHeap` (Min-Heap for efficient TTL management). The interaction between these components, including the logic for `handleMsg` and `onRowSubmit`, is being formalized.
> 
> 
> **Defining the Component Hook**
> 
> I'm presently building the `useStockTable` hook. My approach centers on a `rowsRef` array for data, a `stockIndex` (Map) for rapid `stockId` lookups, and a `expiryHeap` (Min-Heap) for TTL management. The hook's focus will be efficiently managing the interactions between these structures.
> 
> 
> **Defining Helper Components and State**
> 
> I'm now determining how to structure the custom hook. I am focusing on what needs to be stored in the internal references and external state. Also, I'm defining the `expiryManager` and how it will interact with the Min-Heap. The plan is to have a `rowsRef` array (mutable for data processing), a `stockIndex` map, and an `expiryHeap`.
> 
> 
> **Structuring the Component**
> 
> I'm now determining how to structure the custom hook. I am focusing on what needs to be stored in the internal references and external state. Also, I'm defining the `expiryManager` and how it will interact with the Min-Heap. The plan is to have a `rowsRef` array (mutable for data processing), a `stockIndex` map, and an `expiryHeap`.
> 
> 
> **Refining Data Management**
> 
> I'm now fully immersed in the design phase. I've opted for a `Map` structure indexed by `stockId` that points to an object containing references (IDs) for unreplied and replied rows in the `rowData` array. This should drastically improve lookup times. Next, I am formalizing the `handleMsg` logic, including the interaction with the aforementioned `Map`.
> 
> 
> **Implementing the Data Hook**
> 
> I'm presently building the `useStockTable` hook. My approach centers on a `rowsRef` array for data, a `stockIndex` (Map) for rapid `stockId` lookups, and an `expiryHeap` (Min-Heap) for TTL management. The hook's focus will be efficiently managing the interactions between these structures.
> 
> 
Here is a complete solution designed for high performance and strict adherence to your requirements.

### Key Architectural Decisions for Performance

1.  **Data Structure**:
    *   **`rowData` (Array)**: Kept as a React State for rendering, but manipulated via a Ref to avoid closure staleness and unnecessary re-renders during calculation.
    *   **`stockIndex` (Map)**: A `Map<StockId, { unrepliedId, repliedId }>` allows O(1) lookups to enforce the "1 unreplied, 1 replied" constraint without scanning the array.
    *   **`ttlMetadata` (Map)**: Stores `ttl` and `isExpiry` separately from the display data, as requested.
    *   **`ExpiryHeap` (Min-Heap)**: A binary heap is used to manage TTLs. This allows us to find the *next* expiring item in O(1) and insert in O(log N). This is significantly more efficient than iterating through the list or setting hundreds of individual `setTimeout` calls.

2.  **Event Loop Optimization**:
    *   Instead of one timer per row, we use **one single recursive timeout**. It always sleeps exactly until the *next* item in the Heap is due to expire.

### The Solution

```javascript
import React, { useState, useRef, useEffect, useCallback } from 'react';

// --- 1. High Performance Data Structures ---

/**
 * MinHeap implementation to efficiently manage TTL.
 * The root (index 0) is always the item with the earliest expiration time.
 */
class ExpiryHeap {
    constructor() {
        this.heap = [];
    }

    push(node) {
        // node: { id, expiryTime }
        this.heap.push(node);
        this._bubbleUp();
    }

    peek() {
        return this.heap[0];
    }

    pop() {
        const top = this.heap[0];
        const bottom = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = bottom;
            this._sinkDown();
        }
        return top;
    }

    remove(id) {
        const idx = this.heap.findIndex(n => n.id === id);
        if (idx === -1) return;
        
        // Move last item to this slot and re-balance
        const bottom = this.heap.pop();
        if (idx < this.heap.length) {
            this.heap[idx] = bottom;
            this._bubbleUp(idx);
            this._sinkDown(idx);
        }
    }

    _bubbleUp(index = this.heap.length - 1) {
        while (index > 0) {
            const parentIdx = Math.floor((index - 1) / 2);
            if (this.heap[index].expiryTime >= this.heap[parentIdx].expiryTime) break;
            [this.heap[index], this.heap[parentIdx]] = [this.heap[parentIdx], this.heap[index]];
            index = parentIdx;
        }
    }

    _sinkDown(index = 0) {
        const length = this.heap.length;
        const element = this.heap[index];
        while (true) {
            let leftChildIdx = 2 * index + 1;
            let rightChildIdx = 2 * index + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIdx < length) {
                leftChild = this.heap[leftChildIdx];
                if (leftChild.expiryTime < element.expiryTime) {
                    swap = leftChildIdx;
                }
            }
            if (rightChildIdx < length) {
                rightChild = this.heap[rightChildIdx];
                if (
                    (swap === null && rightChild.expiryTime < element.expiryTime) ||
                    (swap !== null && rightChild.expiryTime < leftChild.expiryTime)
                ) {
                    swap = rightChildIdx;
                }
            }
            if (swap === null) break;
            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
            index = swap;
        }
    }
}

// --- 2. Mock API ---
const cancelOrder = (id) => {
    console.log(`[API] Order Cancelled for Row ID: ${id}`);
    // Implement actual RESTful request here
};

// --- 3. Main Component ---

const StockTableFeature = () => {
    // The main display state
    const [rowData, setRowData] = useState([]);

    // Refs to hold mutable data without triggering re-renders during logic processing
    const rowDataRef = useRef([]); 
    
    // Map<StockId, { unrepliedId: string | null, repliedId: string | null }>
    // Tracks which rows belong to which stock to enforce the "Max 2" rule efficiently.
    const stockIndexRef = useRef(new Map());

    // Stores metadata not needed for display (ttl, isExpiry)
    // Map<RowId, { ttl: number, isExpiry: boolean }>
    const metaDataRef = useRef(new Map());

    // MinHeap for TTL management
    const expiryHeapRef = useRef(new ExpiryHeap());
    
    // Timer reference for the single TTL loop
    const ttlTimerRef = useRef(null);

    // Helper to generate unique ID
    const generateId = () => '_' + Math.random().toString(36).substr(2, 9);

    // --- TTL Logic ---

    const scheduleNextExpiry = useCallback(() => {
        if (ttlTimerRef.current) clearTimeout(ttlTimerRef.current);

        const nextItem = expiryHeapRef.current.peek();
        if (!nextItem) return;

        const now = Date.now();
        const delay = Math.max(0, nextItem.expiryTime - now);

        ttlTimerRef.current = setTimeout(() => {
            handleExpiry();
        }, delay);
    }, []);

    const handleExpiry = () => {
        const now = Date.now();
        let nextItem = expiryHeapRef.current.peek();

        // Process all items that have expired (in case multiple expire at same ms)
        while (nextItem && nextItem.expiryTime <= now) {
            const expiredNode = expiryHeapRef.current.pop();
            
            // 1. Call API
            cancelOrder(expiredNode.id);

            // 2. Remove from UI
            removeRowById(expiredNode.id);
            
            nextItem = expiryHeapRef.current.peek();
        }

        // Schedule next check
        scheduleNextExpiry();
    };

    // --- Core Data Management ---

    const removeRowById = (id) => {
        const index = rowDataRef.current.findIndex(r => r.id === id);
        if (index === -1) return;

        const row = rowDataRef.current[index];
        
        // Clean up Index Map
        const stockInfo = stockIndexRef.current.get(row.stockId);
        if (stockInfo) {
            if (stockInfo.unrepliedId === id) stockInfo.unrepliedId = null;
            if (stockInfo.repliedId === id) stockInfo.repliedId = null;
            // If both empty, delete stock key (optional, saves memory)
            if (!stockInfo.unrepliedId && !stockInfo.repliedId) {
                stockIndexRef.current.delete(row.stockId);
            }
        }

        // Clean up Metadata
        metaDataRef.current.delete(id);

        // Remove from Array
        rowDataRef.current.splice(index, 1);
        
        // Update State
        setRowData([...rowDataRef.current]);
    };

    // --- WebSocket Handler ---

    const handleMsg = useCallback((msg) => {
        const { time, stockId } = msg;
        const newId = generateId();

        // 1. Get or Initialize Stock Index
        if (!stockIndexRef.current.has(stockId)) {
            stockIndexRef.current.set(stockId, { unrepliedId: null, repliedId: null });
        }
        const stockRec = stockIndexRef.current.get(stockId);

        // 2. Constraint: Only one unreplied row per stockId
        // If there is an existing unreplied row, remove it first.
        if (stockRec.unrepliedId) {
            // Find index of old unreplied
            const oldIdx = rowDataRef.current.findIndex(r => r.id === stockRec.unrepliedId);
            if (oldIdx !== -1) {
                rowDataRef.current.splice(oldIdx, 1);
                metaDataRef.current.delete(stockRec.unrepliedId);
                // Note: We don't need to remove from Heap because unreplied rows don't have TTL yet
            }
        }

        // 3. Create New Row Object
        const newRow = {
            id: newId, // Internal ID for tracking
            time: time,
            stockId: stockId,
            repliedTime: '',
            qty: '',
            price: ''
        };

        // 4. Update Index
        stockRec.unrepliedId = newId;

        // 5. Add to Data (FIFO Logic)
        rowDataRef.current.push(newRow);

        // 6. Max 300 Items Constraint
        if (rowDataRef.current.length > 300) {
            const removedRow = rowDataRef.current.shift(); // Remove oldest
            
            // Cleanup index for the removed row
            const removedStockRec = stockIndexRef.current.get(removedRow.stockId);
            if (removedStockRec) {
                if (removedStockRec.unrepliedId === removedRow.id) removedStockRec.unrepliedId = null;
                if (removedStockRec.repliedId === removedRow.id) removedStockRec.repliedId = null;
            }
            
            // Cleanup metadata/heap if the oldest row happened to have a TTL (rare but possible)
            if (metaDataRef.current.has(removedRow.id)) {
                metaDataRef.current.delete(removedRow.id);
                expiryHeapRef.current.remove(removedRow.id);
            }
        }

        // 7. Update React State
        setRowData([...rowDataRef.current]);
    }, []);

    // --- User Interaction Handler ---

    const onRowSubmit = useCallback((submittedRow) => {
        // submittedRow contains: { ...row, qty, price, ttl, isExpiry }
        
        const rowIndex = rowDataRef.current.findIndex(r => r.id === submittedRow.id);
        if (rowIndex === -1) return;

        const currentRow = rowDataRef.current[rowIndex];
        const stockId = currentRow.stockId;
        const stockRec = stockIndexRef.current.get(stockId);

        // 1. Constraint: Max 1 replied row per stockId.
        // If there is ALREADY a replied row (and it's not this one), remove the old one.
        if (stockRec && stockRec.repliedId && stockRec.repliedId !== currentRow.id) {
            const oldRepliedIdx = rowDataRef.current.findIndex(r => r.id === stockRec.repliedId);
            if (oldRepliedIdx !== -1) {
                const oldId = rowDataRef.current[oldRepliedIdx].id;
                rowDataRef.current.splice(oldRepliedIdx, 1);
                
                // Cleanup old replied metadata
                metaDataRef.current.delete(oldId);
                expiryHeapRef.current.remove(oldId);
                
                // Adjust rowIndex if the removal shifted our current row
                // (If old row was before current row)
                if (oldRepliedIdx < rowIndex) {
                    // We need to find the index again to be safe
                    // or just decrement, but findIndex is safer given the splice
                }
            }
        }

        // Re-find index as array might have shifted due to removal above
        const updatedIndex = rowDataRef.current.findIndex(r => r.id === submittedRow.id);
        if (updatedIndex === -1) return;

        // 2. Update Row Data for Display
        const updatedRow = {
            ...rowDataRef.current[updatedIndex],
            repliedTime: Date.now(), // Capture submit time
            qty: submittedRow.qty,
            price: submittedRow.price
        };
        
        rowDataRef.current[updatedIndex] = updatedRow;

        // 3. Update Index (Move from unreplied to replied)
        if (stockRec) {
            if (stockRec.unrepliedId === submittedRow.id) stockRec.unrepliedId = null;
            stockRec.repliedId = submittedRow.id;
        }

        // 4. Handle TTL Logic
        // Store hidden variables
        metaDataRef.current.set(submittedRow.id, {
            ttl: submittedRow.ttl,
            isExpiry: submittedRow.isExpiry
        });

        if (!submittedRow.isExpiry && submittedRow.ttl > 0) {
            const expiryTime = Date.now() + (submittedRow.ttl * 1000);
            
            // Add to MinHeap
            expiryHeapRef.current.push({
                id: submittedRow.id,
                expiryTime: expiryTime
            });

            // Ensure timer is running for the earliest item
            scheduleNextExpiry();
        }

        // 5. Update State
        setRowData([...rowDataRef.current]);

    }, [scheduleNextExpiry]);


    // --- Simulation for Testing (Optional) ---
    // Uncomment to test incoming messages
    /*
    useEffect(() => {
        const interval = setInterval(() => {
            const stocks = ['AAPL', 'GOOG', 'MSFT', 'TSLA'];
            const randomStock = stocks[Math.floor(Math.random() * stocks.length)];
            handleMsg({
                time: Date.now(),
                stockId: randomStock
            });
        }, 1000); // 1 msg per second
        return () => clearInterval(interval);
    }, [handleMsg]);
    */

    // --- Render ---
    // Note: This is a basic table representation. 
    // In a real app, you would pass rowData and onRowSubmit to your existing Table component.
    return (
        <div style={{ padding: '20px', fontFamily: 'monospace' }}>
            <h3>High Performance Trade Monitor</h3>
            <p>Rows: {rowData.length} / 300</p>
            <table border="1" style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead>
                    <tr style={{ background: '#f0f0f0' }}>
                        <th>Time</th>
                        <th>Stock ID</th>
                        <th>Replied Time</th>
                        <th>Qty</th>
                        <th>Price</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {rowData.map((row) => (
                        <tr key={row.id} onDoubleClick={() => {
                            // Mocking the Dialog Open
                            const qty = prompt("Enter Qty:", "100");
                            if(qty === null) return;
                            const price = prompt("Enter Price:", "50.00");
                            const ttl = prompt("TTL (seconds):", "30");
                            // Mock submit
                            onRowSubmit({
                                ...row,
                                qty,
                                price,
                                ttl: parseInt(ttl) || 30,
                                isExpiry: false // Mocking checkbox unchecked
                            });
                        }}>
                            <td>{new Date(row.time).toLocaleTimeString()}</td>
                            <td>{row.stockId}</td>
                            <td>{row.repliedTime ? new Date(row.repliedTime).toLocaleTimeString() : '-'}</td>
                            <td>{row.qty}</td>
                            <td>{row.price}</td>
                            <td>
                                {!row.repliedTime && <small>Double Click to Reply</small>}
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

export default StockTableFeature;
```

### Explanation of Logic

1.  **`handleMsg(msg)`**:
    *   **Lookup**: Checks `stockIndexRef` to see if this Stock ID already has an `unrepliedId`.
    *   **Replacement**: If an unreplied row exists, it finds it in the array and removes it. This ensures "only one unreplied row per stockId".
    *   **Insertion**: Adds the new row to the end.
    *   **FIFO**: If length > 300, `shift()` removes the oldest. We also clean up the `stockIndex` and `expiryHeap` for that removed row to prevent memory leaks.
    *   **State Sync**: Updates `rowData` state.

2.  **`onRowSubmit(row)`**:
    *   **Constraint Check**: Checks if a `repliedId` already exists for this stock. If so, removes the *old* replied row to maintain the "Max 2 rows per stock" rule (1 unreplied, 1 replied).
    *   **Update**: Updates the row in the array with `qty`, `price`, and `repliedTime`.
    *   **Index Update**: Moves the ID from `unrepliedId` to `repliedId` in the `stockIndexRef`.
    *   **TTL Handling**:
        *   Stores `ttl` and `isExpiry` in `metaDataRef` (not in `rowData` as requested).
        *   If `!isExpiry`, calculates the absolute `expiryTime` and pushes `{ id, expiryTime }` into the **MinHeap**.
        *   Calls `scheduleNextExpiry()`.

3.  **TTL System (`scheduleNextExpiry` & `handleExpiry`)**:
    *   **Efficiency**: This is the critical performance piece. Instead of `setTimeout` for every row (which creates massive overhead), we look at the **Heap Root** (earliest expiry).
    *   We set **one single timeout** for the difference between `now` and `root.expiryTime`.
    *   When the timer fires, we execute the API call (`cancelOrder`), remove the row, and then look at the *new* root to set the next single timer.

4.  **Memory Management**:
    *   We aggressively clean up the `stockIndexRef`, `metaDataRef`, and `expiryHeapRef` whenever a row is removed (either by FIFO overflow, manual replacement, or TTL expiry).